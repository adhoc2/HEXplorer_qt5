/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class a2l_quex_lexer and its memento class.
 * (5) Constructor and init core of a2l_quex_lexer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.59.7.
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____A2L_QUEX_LEXER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____A2L_QUEX_LEXER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____A2L_QUEX_LEXER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "a2l_quex_lexer-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* a2l_quex_lexer */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */

#   line 6 "a2l_quex_lexer.qx"

#include <cstdlib>  // for: atoi()

#   line 56 "a2l_quex_lexer"


/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode"
#endif
#include <quex/code_base/analyzer/headers>

#include "a2l_quex_lexer-token_ids"
#include "a2l_quex_lexer-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_ONE_AND_ONLY) = 0
};

        extern QUEX_NAME(Mode)  QUEX_NAME(ONE_AND_ONLY);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class a2l_quex_lexer {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ a2l_quex_lexer(const a2l_quex_lexer&);
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_CHARACTER  char_type;

    a2l_quex_lexer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
                   QUEX_TYPE_CHARACTER* BufferEndOfContentP   = 0x0,
                   const char*          CharacterEncodingName = 0x0,
                   bool                 ByteOrderReversionF   = false);
    a2l_quex_lexer(const std::string&   Filename,       
                   const char*          CharacterEncodingName = 0x0,
                   bool                 ByteOrderReversionF   = false);
    a2l_quex_lexer(std::istream*        p_input_stream, 
                   const char*          CharacterEncodingName = 0x0,
                   bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    a2l_quex_lexer(std::wistream*       p_input_stream,
                   const char*          CharacterEncodingName = 0x0,
                   bool                 ByteOrderReversionF   = false);
#   endif
    a2l_quex_lexer(std::FILE*           input_fh,       
                   const char*          CharacterEncodingName = 0x0,
                   bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
        a2l_quex_lexer(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
                       const char*                              CharacterEncodingName = 0x0,
                       bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~a2l_quex_lexer();

    /* Direct Access to Memory */
    void*                 buffer_fill_region_append(void* ContentBegin, 
                                                    void* ContentEnd);
    void*                 buffer_fill_region_append_conversion(void* ContentBegin, 
                                                               void* ContentEnd);
    void*                 buffer_fill_region_append_conversion_direct(void* ContentBegin, 
                                                                      void* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    /* -- activate/deactivate byte order reversion (big-/little-endian)    */
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                  */
#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                       */
    void                receive(QUEX_TYPE_TOKEN**);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)  
    /* (2) Single Token
     * 
     *   When there is only one single token as interface, than the
     *   token id is returned. This enables a minimal setup were the
     *   analyzer may only return a token id and does not work on tokens. 
     *
     *   Command line options: --token-policy  single                      */
    QUEX_TYPE_TOKEN_ID  receive();
#   else
#       error "This section should never be compiled."
#   endif

    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*     token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_p_set(QUEX_TYPE_TOKEN*);
       QUEX_TYPE_TOKEN*  token_p_switch(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool              token_queue_is_empty();
       void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
       void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
       void              token_queue_switch(QUEX_TYPE_TOKEN** queue, 
                                            size_t*           size); 
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int              ModeID);       
    int                map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending happens only via 'self_send*(...)' macros
    void        send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const             { return line_number_at_begin(); }
    size_t      line_number_at_begin() const    { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const      { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)       { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const             { return column_number_at_begin(); }
    size_t      column_number_at_begin() const    { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const      { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)       { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                    { return counter._indentation; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

public:

    void        set_callback_on_buffer_content_change(void (*callback)(QUEX_TYPE_CHARACTER*, 
                                                                       QUEX_TYPE_CHARACTER*));

    template <class InputHandleT> void reset(InputHandleT*  input_handle, 
                                             const char*    CharacterEncodingName = 0x0);
    void                               reset(const char*    CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

    QUEX_TYPE_CHARACTER*               reset_buffer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                                                    size_t               BufferMemorySize,
                                                    QUEX_TYPE_CHARACTER* BufferEndOfContentP,  
                                                    const char*          CharacterEncodingName = 0x0);

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(InputHandleT*            sh, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_NAME(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(ONE_AND_ONLY_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(ONE_AND_ONLY_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

public:
    // At least warn those, who still use the old interface ...
    void                  get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p)  { (void)result_p; get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_pp) { (void)result_pp; get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
void
QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize,
                            QUEX_TYPE_CHARACTER*   BufferEndOfFileP)
{
    __quex_assert(QUEX_NAME(ModeID_ONE_AND_ONLY) < 1);

     QUEX_NAME(ONE_AND_ONLY).id   = QUEX_NAME(ModeID_ONE_AND_ONLY);
     QUEX_NAME(ONE_AND_ONLY).name = "ONE_AND_ONLY";
     QUEX_NAME(ONE_AND_ONLY).analyzer_function = QUEX_NAME(ONE_AND_ONLY_analyzer_function);
#    if      defined(QUEX_OPTION_INDENTATION_TRIGGER) \
        && ! defined(QUEX_OPTION_INDENTATION_DEFAULT_HANDLER)
     QUEX_NAME(ONE_AND_ONLY).on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#    endif
     QUEX_NAME(ONE_AND_ONLY).on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
     QUEX_NAME(ONE_AND_ONLY).on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#    if      defined(QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK)
     QUEX_NAME(ONE_AND_ONLY).has_base       = QUEX_NAME(ONE_AND_ONLY_has_base);
     QUEX_NAME(ONE_AND_ONLY).has_entry_from = QUEX_NAME(ONE_AND_ONLY_has_entry_from);
     QUEX_NAME(ONE_AND_ONLY).has_exit_to    = QUEX_NAME(ONE_AND_ONLY_has_exit_to);
#    endif
        me->mode_db[QUEX_NAME(ModeID_ONE_AND_ONLY)] = &(QUEX_NAME(ONE_AND_ONLY));


    QUEX_NAME(construct_basic)(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_NAME(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
QUEX_NAME(Memento)*
QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();
    
    (void)InputName;
    (void)input_handle;

#   ifndef __QUEX_OPTION_PLAIN_C
    /* Use placement 'new' for explicit call of constructor. 
     * Necessary in C++: Trigger call to constructor for user defined members.   */
    new ((void*)memento) QUEX_NAME(Memento);
#   endif

    memento->_parent_memento                  = self._parent_memento;
    memento->buffer                           = self.buffer;
    memento->__current_mode_p                 = self.__current_mode_p; 
    memento->current_analyzer_function        = self.current_analyzer_function;
#   if    defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
       || defined(QUEX_OPTION_ASSERTS)
    memento->DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
#   ifdef __QUEX_OPTION_COUNTER
    memento->counter                          = self.counter;
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    memento->accumulator                      = self.accumulator;
#   endif
    memento->__file_handle_allocated_by_constructor = self.__file_handle_allocated_by_constructor;

    /* Deriberately not subject to include handling:
     *    -- Mode stack.
     *    -- Token and token queues.
     *    -- Post categorizer.                                                 */

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

#ifndef __QUEX_OPTION_PLAIN_C
QUEX_INLINE 
#endif
void
QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*me)
    self._parent_memento                  = memento->_parent_memento;
    self.buffer                           = memento->buffer;
    self.__current_mode_p                 = memento->__current_mode_p; 
    self.current_analyzer_function        = memento->current_analyzer_function;
#   if    defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;
#   endif
#   ifdef __QUEX_OPTION_COUNTER
    self.counter                          = memento->counter;
#   endif
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    self.accumulator                      = memento->accumulator;
#   endif
    self.__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
    
#   ifndef __QUEX_OPTION_PLAIN_C
    /* Counterpart to placement new: Explicit destructor call.
     * Necessary in C++: Trigger call to destructor for user defined members.  */
    memento->~QUEX_NAME(Memento_tag)();
#   endif

    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/unicode.i"
#endif
#include <quex/code_base/analyzer/headers.i>


/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I

namespace quex {


inline
/* NOTE: If you get an error here, then your configuration
 *       file does not declare QUEX_TYPE0_TOKEN as Token. 
 *       The following weirdly typed constructor shall break in
 *       this particular case.                                        */
Token::QUEX_TYPE0_TOKEN()
/*****************************************************/
{
#   define self (*this)

#   undef  self
}

inline
Token::Token(const Token& Other)
{
   QUEX_NAME_TOKEN(copy)(this, &Other);
#  define self (*this)

#  undef  self
}

inline
Token::~Token()
{
#  define self (*this)

#  undef  self
}

inline void
QUEX_NAME_TOKEN(construct)(Token* __this)
{
    /* Explicit constructor call by 'placement new' */
    new ((void*)__this) QUEX_TYPE_TOKEN;
}

inline void
QUEX_NAME_TOKEN(destruct)(Token* __this)
{
    __this->QUEX_TYPE0_TOKEN::~QUEX_TYPE0_TOKEN();  
}

inline void
QUEX_NAME_TOKEN(copy)(Token* __this, const Token* __That)
{
#  define self  (*__this)
#  define Other (*__That)
    (void)__this;
    (void)__That;

#   line 33 "C:/Programme/quex/quex-0.59.7/quex/code_base/token/CppDefault.qx"

        self._id    = Other._id;
        self.text   = Other.text;
        self.number = Other.number;
    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    #       ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
            self._line_n = Other._line_n;
    #       endif
    #       ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
            self._column_n = Other._column_n;
    #       endif
    #   endif
   

#   line 593 "a2l_quex_lexer"

#  undef Other
#  undef self
   /* If the user even misses to copy the token id, then there's
    * something seriously wrong.                                 */
   __quex_assert(__this->_id == __That->_id);
#ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#  ifdef QUEX_OPTION_LINE_NUMBER_COUNTING
   __quex_assert(__this->_line_n == __That->_line_n);
#  endif
#  ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
   __quex_assert(__this->_column_n == __That->_column_n);
#  endif
#endif
}

QUEX_INLINE bool 
QUEX_NAME_TOKEN(take_text)(Token*           __this, 
                           QUEX_TYPE_ANALYZER*        __analyzer, 
                           const QUEX_TYPE_CHARACTER* Begin, 
                           const QUEX_TYPE_CHARACTER* End)
{
#  define self      (*__this)
#  define analyzer  (*__analyzer)
    (void)__this;
    (void)__analyzer;

#   line 113 "C:/Programme/quex/quex-0.59.7/quex/code_base/token/CppDefault.qx"

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("%lX ", (long)__this);
            printf("previous:  '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
            printf("take_text: '");
            for(it = (QUEX_TYPE_CHARACTER*)Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* It cannot be assumed that the lexeme is zero terminated. */
        self.text.assign(Begin, End-Begin);

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_CHARACTER* it = 0x0;
            printf("after:     '");
            for(it = (QUEX_TYPE_CHARACTER*)self.text.c_str(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim owneship over it.                       */
        return false;      
   

#   line 655 "a2l_quex_lexer"

#  undef analyzer
#  undef self
}

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
QUEX_INLINE size_t 
QUEX_NAME_TOKEN(repetition_n_get)(QUEX_TYPE_TOKEN* __this)
{
#   define self      (*__this)
    (void)__this;
    
#   line 150 "C:/Programme/quex/quex-0.59.7/quex/code_base/token/CppDefault.qx"

       return self.number;
   

#   line 673 "a2l_quex_lexer"

#   undef  self
}

QUEX_INLINE void 
QUEX_NAME_TOKEN(repetition_n_set)(QUEX_TYPE_TOKEN* __this, size_t N)
{
#   define self      (*__this)
    (void)__this;
    (void)N;
    
#   line 146 "C:/Programme/quex/quex-0.59.7/quex/code_base/token/CppDefault.qx"

       self.number = N;
   

#   line 690 "a2l_quex_lexer"

#   undef  self
}
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */

} /* Closing Namespace 'quex' */


#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____QUEX____TOKEN_I */


#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____A2L_QUEX_LEXER */
